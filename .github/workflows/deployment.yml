name: Deployment Pipeline

on:
  workflow_call:
    inputs:
      performance-test:
        required: false
        type: bool
        default: true
      deployment:
        required: false
        type: bool
        default: true
      container_name:
        required: false
        type: string
      artifact_id:
        required: false
        type: string
      comments:
        required: false
        type: string

  workflow_dispatch:
    inputs: 
      source:
        description: 'Would you like to use a remote or local source?'
        required: true
        type: choice
        choices:
          - remote
          - local
      identifier:
        description: 'Enter the container image/Artifact ID if remote (ex. latest, id, artifact_id)'
        required: false
        type: string
      emulation:
        description: 'Make an additional image for the x86 platform?'
        required: false
        type: boolean
        default: false

jobs:
  staging:
    runs-on: self-hosted
    permissions:
      packages: read
    outputs:
      identifier: ${{ steps.find-source.outputs.identifier }}
      artifact_id: ${{ steps.set-artifact-id.outputs.artifact_id }}
    steps:
      - name: Determine staging source
      id: find-source
      run: |
        if [ -z "${{ github.events.inputs.source }}"]; then
          echo "container_name=$container_name" >> $GITHUB_ENV
          echo "::set-output name=container_name::$SOURCE"
          echo "SOURCE=local" >> $GITHUB_ENV
          echo "::set-output name="
        fi
        ~/Container/find.sh ${{ github_eve }} ${{  }} ${{  }}
        echo "source found: "

      - name: Load Container

      - name: Load Artifact

      - name: Download Container

      - name: Download Artifact

      - name: Download artifact
        uses: actions/download-artifact@v2
        with:
          name: ${{ steps.set-artifact-id.outputs.artifact_id }}
    
      - name: Display structure of downloaded files
        run: ls -R your/destination/dir
      - name: Load Docker image from artifact
        run: |
          tar -xvf ${{ steps.set-artifact-id.outputs.artifact_id }}.tar.gz -O | docker load
          echo "The artifact has been loaded into docker successfully"
      # if both empty, default to container
      # for container, check QEMU is checked, if so, also make an additional for x86 platform

      - name: Create QEMU container 

  # call benchmkaring separately 
  benchmarking:
    needs: [staging]
    runs-on: nvidia-jetson
    permissions:
      checks: write
    steps:
      - name: Run sample workload
      - run: sudo docker run ${container.name} --runtime nvidia -it --rm --network=host custom_container -v /dir/:/dir/
      - name: Copy/publish benchmarking log file w/ metadata
      - run: |
        echo "Benchmarking completed, please check the Github Actions Dashboard to view the log report"
      # cat output from log file 

  # publishing to docker hub (needs approval) based on the performance report or not
  # could make issue that needs to be closed or updated to confirm
  publishing:
    needs: [benchmarking]
    runs-on: nvidia-jetson
    permissions:
      id-token: write
      checks: write
    environment: production
    steps:
      - name: Login to Docker Registry ${{ env.REGISTRY }}
        uses: docker/login-action@v2.1.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@4.4.0
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
      - name: Build and push Docker image
        id: build-and-push
        uses: docker/build-push-action@v4.0.0
        with:
          context: .
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
      - name: Publish image to Docker Hub
        run: |
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        echo "In order to run the Docker container on another machine, use the the docker image id: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest and follow the guide at: (website tbd)"


  # now that you have chosen either an artifact or image to be the main one, this one should be retagged, all others should be removed except bases and should be as easy as docker run...
  # or possibly update the bash aliases file
  # copy the new repository artifact to the jetson and replace the old one
  deploying:
    runs-on: nvidia-jetson
    with:
      environment: production
    permissions:
      packages: read
    steps:
      id: build-and-push
      uses: docker/build-push-action@v4.0.0
      with:
        context: .
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}

      - name: Activate setup
      run: |
      cd ~/Container/
      docker-compose up

  explore:
    runs-on: nvidia-jetson
    steps:
      - name: Check current directory
        run: pwd

      - name: List files in current directory
        run: ls -la

      - name: List root directory
        run: ls -la /

      - name: List runner's work directory
        run: ls -la /home/runner/work

      - name: List runner's temp directory
        run: ls -la /home/runner/_temp

      - name: List runner's tool directory
        run: ls -la /home/runner/_tool

      - name: List GitHub workspace directory
        run: ls -la ${{ github.workspace }}

      - name: Show environment variables
        run: env

  cleanup:
    runs-on: nvidia-jetson
    steps:
      - name: Clean previous runs
        run: |
          rm -rf /home/runner/_temp/* || true
          rm -rf /home/runner/work/${{ github.repository }}/* || true